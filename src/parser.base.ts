/**
 * A generic base class for a parser, which supplies some standard functions
 * for checking and accepting tokens, but lacks any language-specific
 * parsing.
 * 
 * Although mostly we want to parse text, this class is written in a generic
 * way so that the same base can also be used to crawl through sequences of
 * objects instead of characters.
 *
 * The class' generic signature represents:
 *
 * @template RawInput             The unparsed input that is fed to the lexer, 
 * e.g. a string.
 * @template TokenInterface       The kind of token that will be generated by 
 * the lexer.
 * @template TokenTypeIdentifier  The type of the object that will be used to 
 * tell tokens apart, e.g. a string serving as the label of a lexical category.
 * @template ParsedOutput         The parsed output based on the input, e.g. an 
 * abstract syntax tree.
 */
export default abstract class ParserBase<
  RawInput,
  TokenInterface,
  TokenTypeIdentifier,
  ParsedOutput,
> {
  protected currentPosition: number = 0;
  protected tokens: TokenInterface[] = [];
  protected errors: string[] = [];
  protected abstract source: RawInput

  /**
   * This method will be implemented by subclasses to provide the orchestration
   * of their own parse tree.
   * 
   * Your implementation should set the class' `source` property to
   * this method's input.
   *
   * @param input   The `RawInput` type to be parsed.
   * @returns       The `ParsedOutput` type resulting from the parse.
   */
  public abstract parse(input: RawInput): ParsedOutput;

  /**
   * This method will be implemented by subclasses to provide a means by which
   * the parser can check whether the object of type `TokenInterface`
   * at the current position can be identified by the object of type
   * `TokenTypeIdentifier`
   *
   * For example, the implementation of the `TokenInterface` might be
   * categorized according to a label stored in a string enum implementing the
   * `TokenTypeIdentifier` (i.e. `ConcreteToken.tokenType: string`)
   *
   * @param identifier  A means by which the item `TokenInterface` can be
   *                    categorized.
   */
  protected abstract check(identifier: TokenTypeIdentifier): boolean;

  /**
   * This method will be implemented by subclasses to provide an error message
   * when the parser fails to `consume` an item of type `TokenInterface`,
   * using appropriate data from it.
   *
   * @param errorMsg    A description of the error, to which this method will
   *                    add specific item data to complete the message.
   */
  protected abstract makeErrorMsg(errorMsg: string): string;

  /**
   * Return the parser to its initial state.
   */
  public reset(): void {
    this.currentPosition = 0;
    this.tokens = [];
    this.errors = [];
  }

  /**
   * Indicate whether the parser has reached the end of the token stream.
   *
   * @returns True, if the parser has reached the end of the token stream.
   */
  protected isAtEnd(): boolean {
    return this.currentPosition >= this.tokens.length;
  }

  /**
   * Look at the token that is (+/-) n tokens from the current index.
   *
   * @param nodes The number of tokens ahead of the current index to check.
   *
   * @returns A token, if one is found at the requested position, or null if not.
   */
  protected lookAround(nodes: number): TokenInterface | null {
    let pos = this.currentPosition + nodes;
    if (pos < 0 || pos >= this.tokens.length) {
      return null;
    }
    return this.tokens[pos];
  }

  /**
   * Return the current token and move the counter ahead by one node.
   *
   * @returns The token at the previously-current position.
   */
  protected advance(): TokenInterface {
    let node = this.tokens[this.currentPosition];
    this.currentPosition += 1;
    return node;
  }

  /**
   * Asssert that the next token can be identified by the given instance of
   * the type of `TokenTypeIdentifier`, advance the counter, and return the
   * token.
   *
   * If this assertion fails, then an error is raised, which can be handled
   * in the main parse loop (e.g. to log then resynchronize)
   *
   * @param identifier
   * @param errorMessage
   * @returns
   */
  protected consume(
    identifier: TokenTypeIdentifier,
    errorMessage: string
  ): TokenInterface {
    // Success path.
    if (this.check(identifier)) {
      return this.advance();
    }
    throw this.addError(this.makeErrorMsg(errorMessage));
  }

  /**
   * Indicate whether the parser had an error during parsing.
   *
   * @returns True, if at least one error was encountered.
   */
  protected hadError(): boolean {
    return this.errors.length > 0;
  }

  /**
   * Return the single token at the position before the current position,
   * or null if there is none.
   *
   * @returns A token or null if none exists
   */
  protected previous(): TokenInterface | null {
    return this.lookAround(-1);
  }

  /**
   * Return the token at the current position, or null if there is none.
   *
   * @returns A token or null if none exists
   */
  protected current(): TokenInterface | null {
    return this.lookAround(0);
  }

  /**
   * Return the token at counter +1 or null if none exists.
   * @returns   A token or null if none exists.
   */
  protected peek(): TokenInterface | null {
    return this.lookAround(1);
  }

  /**
   * Return the token at counter +2 or null if none exists.
   * @returns   A token or null if none exists.
   */
  protected peekNext(): TokenInterface | null {
    return this.lookAround(2);
  }

  /**
   * Check whether a token can be recognized with the given identifier
   * at the current position and if so return true and advance the counter.
   *
   * @param identifiers   The identifier (e.g. token type) to check.
   * @returns             True, if the token at current position can be
   *                      recognized with the given identifier.
   */
  protected match(...identifiers: TokenTypeIdentifier[]): boolean {
    for (let identifier of identifiers) {
      if (this.check(identifier)) {
        this.advance();
        return true;
      }
    }
    return false;
  }

  /**
   * Register an error with the error log.
   * 
   * @param message   The message thar accompanies the error.
   */
  protected addError(message: string) {
    this.errors.push(message);
    return Error(message)
  }
}
